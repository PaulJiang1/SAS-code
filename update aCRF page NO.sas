/*-----------------------------------------------------------------------------
PAREXEL INTERNATIONAL LTD
Sponsor / Protocol No: Macro tool
PXL Study Code: 
SAS Version: SAS 9.3
Operating System: Windows 
-------------------------------------------------------------------------------
Author: Lianbo Zhang $LastChangedBy:  $
Creation / modified: Tuesday, January 26, 2016 11:42:31 / $LastChangedDate: $
Program Location/name: $HeadURL:$
Files Created: This program is to check aCRF annotation's page number and assign them into SDTM spec.
 
Update hisitory:
2016-1-30: special condition: update for VISIT CRF page = null issue
           logical improve : update for the situation "same VARIABLE name but different SUPPDOMAIN"
           program bug : update for miss "file print;" in VARDEF 
2016-8-18: update the QSCAT join part, fix the tail or lead blank issue caused by length, 
           when we are using put(xxx,$fmt.);
2016-8-18: update the QSCAT filter part, fix SUPP var whose IDVAR =  QSCAT ;
2016-9-7 : compress continous blank in annotation at first ( compbl ) ; 
2016-9-7 : add font style check ;
-------------------------------------------------------------------------------
MODIFICATION HISTORY: Subversion $Rev:  $
-----------------------------------------------------------------------------*/


/********************************************************************************
 *  Generated by XML Mapper, 904000.0.0.20130522190000_v940
 ********************************************************************************/

/*  1, please make sure your SDTM spec's  VARORDER <column2> are numeric format*/
/*  2, please make sure your SDTM spec's  VALDEF's VALUEOID and VALVAL are sorted in order */
/*  3, please make sure your SDTM spec's CRF page column is text format*/
/*  4, please backup your orgianl spec, before using this macro*/
/*  5, please make sure your annotation is CRF is clean, and only have text box , no highlight or comments note*/
/*  6, please check your log after running this macro, if have some warnning, you should pay attention
       usually it is due to your spec columns have different formats, SAS don't support different attribute
       within one variable   
*/

/******************************************************************************/
/*  Suppose your QSTESTCD is uniqued, if not please use another version       */
/******************************************************************************/

%let specname=%str(228657 sdtm mapping specifications v 1.0.xlsx);    /*(containing the extend name "XLSX" or other )*/
%let acrf= %str(54767414MMY1006_AnnotatedSDTM_eCRF_ V1.1_20160902) ;    /*only file name*/
%let mainrange=%str(B9:S);  /* for old spec it is  B7:S  ;  for new spec it is B9:S   */
%let supprange=&mainrange;


%macro currentroot;
%global currentroot;
%let currentroot= %sysfunc(getoption(sysin));
%if "&currentroot" eq "" %then %do;
%let currentroot= %sysget(SAS_EXECFILEPATH);
%end;
%mend;
%currentroot
%let saswork=%sysfunc(pathname(work));

%let pgmname=  %scan( %str(&currentroot),-1,\) ; 
%let root=%substr(%str(&currentroot),1,%eval(%index(%str(&currentroot), %str(&pgmname))-1));
%put &root ;

/*  Environment */

options  VALIDMEMNAME=EXTEND;
filename  annotate "&root.&acrf..xfdf";
filename  SXLEMAP "&root.annotation.map";
libname   annotate xmlv2 xmlmap=SXLEMAP access=READONLY;
proc delete data= _ALL_ ;
run;

DATA freetext; SET annotate.freetext;   freetext_page=freetext_page+1 ; run;
DATA p; SET annotate.p; run;
DATA span; SET annotate.span; run;
data annotation;
length annotation $500 ;
  merge p span ;
  by p_ORDINAL;
 freetext_ORDINAL= body_ORDINAL ;
  annotation= catx(' ', p, span);
run;

title "Check annotation font style " ;
data final ;
file print;
  merge annotation(in=a keep= freetext_ORDINAL annotation ) freetext (keep=freetext_ORDINAL  freetext_page defaultstyle) ;
  by freetext_ORDINAL;
  if a;

  if _n_=1 then do;
    re12= prxparse('/font:.*italic bold Arial.*12\.0pt/');
    re10= prxparse('/font:.*italic bold Arial.*10\.0pt/');
  end;
retain re10 re12  ;

if annotation ne '' and not( prxmatch(re10,defaultstyle )>0 or prxmatch(re12,defaultstyle )>0 )
     then put  annotation "in page: " freetext_page  " font style is incorrect , please check" ;
drop re1: ;

  if find(annotation,'NOT SUBMITTED')=0 and 
     find(upcase(annotation),'ANNOTATION')=0 and
     find(upcase(annotation),'NOTE:')=0  and
     find(upcase(annotation),'LINKED TO RELATED')=0 and 
     find(upcase(annotation),'VIA RELREC')=0 
;
/*	remove the annotation such as DM = Demographics etc   */
  if length(annotation)>6 then do ; 
        if   not  (find (compress(annotation),'=')=3 and 
        substr(compress(annotation),1,4) = upcase(substr(compress(annotation),1,4)) and
        substr(compress(reverse(annotation)),1,1) ne upcase(substr(compress(reverse(annotation)),1,1))
     );
  end;
run;

title; 

proc sort data= final nodupkey;
by freetext_page freetext_ORDINAL annotation;
run;

data table1;
  set final ;
  annotation= compbl(annotation);
  annotation= tranwrd(annotation,'= ','=');
  annotation= tranwrd(annotation,' =','=');
  annotation= tranwrd(annotation,'*','');
run;

data valdef_supp1 ;
  set table1;
  length VALVAL $20 ;
  where compress(annotation) like '%inSUPP__whenIDVAR=%' or 
        compress(annotation) like '%inSUPP__whereIDVAR=%';
  VALVAL= scan(annotation,1,' =');
  var2= substr(annotation, find(annotation,'SUPP'), 6 ) ;
  VALUEOID= catx('.', var2,'QNAM');
  keep VALUEOID VALVAL freetext_page freetext_ORDINAL ;
run;

proc sort data= valdef_supp1 nodupkey;
  by VALUEOID VALVAL freetext_page;
run;

/*suppdomain in VALDEF*/

data valdef_supp;
  length page $100;
  set valdef_supp1;
  by VALUEOID VALVAL freetext_page;
  retain page ;
  if first.VALVAL then call missing(page) ;
  page= catx(', ',page, freetext_page) ;  
  if last.VALVAL;
run;

data valdef_testcd;
  set table1;
  where annotation like  '%TESTCD%' ;
  annotation= tranwrd(annotation,' when ','^');
/*  annotation= tranwrd(annotation,' where ','^');*/
  annotation= tranwrd(annotation,' and ','^');
  array element $100 var1-var5;
   do i= 1 to 5;
      element[i]= scan(annotation,i,'^');
      if find(element[i],'TESTCD=')=0 then call missing(element[i]);
      if element[i] ne '' and find(element[i],'LB') ne 1  
/*and find(element[i],'QS') ne 1 */
    then do ;
        VAR=element[i];
        output;
      end;
   end;
  drop i ;
run;

proc sort data= valdef_testcd nodupkey;
  by  VAR  freetext_page ;
run ;

data valdef_testcd_1 /*(where=(find(VALUEOID,'ALL') ne 6))*/;
length page $100 VALVAL $20;
  set valdef_testcd;
  by  VAR  freetext_page ;
  retain page ;
  _freetext_page= cats(freetext_page) ;
  if first.VAR then call missing(page);
  page= catx( ', ',page,_freetext_page ) ;
  VALUEOID= catx('.', substr(var,1,2),scan(var,1,'=') );
  VALVAL=scan(var,2,'=');
  if last.VAR  then output;
  keep VALUEOID VALVAL page freetext_ORDINAL ;
run;


data valdef_CAT ;
  length VALUEOID $200 VALVAL $20;
  set table1;
   where  annotation like  '%QSCAT%'   and find(annotation, 'QSSTAT')=0  and
          annotation not like '%SUPP__ %';
   VALUEOID= catx('.',substr(scan(annotation,1,'='),1,2),scan(annotation,1,'='));
   VALVAL=  scan(annotation,2,'=');
   drop annotation;
run;

proc sort data= valdef_CAT nodupkey;
  by  VALUEOID  VALVAL freetext_page ;
run ;

data valdef_CAT1;
  length page $100;
  set valdef_CAT;
  by VALUEOID  VALVAL freetext_page ;
  retain page ;
  _freetext_page= cats(freetext_page) ;
  if first.VALVAL then call missing(page);
  page= catx( ', ',page,_freetext_page ) ;
  if last.VALVAL  then output;
  keep VALUEOID VALVAL page freetext_ORDINAL ;
run;


proc format ;
value $QSCAT
/*put QSCAT to QSTESTCD's prefix*/
'AUSCAN NRS'='AUSN'
'BDI-II'='BDI'
'BPI SHORT FORM'='BPI2'
'BPIC-SS'='BPIC'
'BPRS MODIFIED'='BPR9'
'C-SSRS BASELINE'='CSS01'
'C-SSRS BASELINE/SCREENING VERSION'='CSS04'
'C-SSRS SINCE LAST VISIT'='CSS02'
'CADSS'='CADS'
'CHRT'='CHR'
'EQ-5D-3L'='EQ5D01'
'EQ-5D-5L'='EQ5D02'
'FACIT-F'='FACT'
'FACT-Leu'='FACT06'
'FACT-P'='FACT04'
'FAQ-NACC'='FAQ02'
'FAQ'='FAQ01'
'FPGA'='FPGA'
'FSS2'='FSS'
'GAD-7'='GAD01'
'GDS SHORT FORM'='GDS02'
'GDS'='GDS01'
'HAQ-DI'='HAQ'
'HCV SIQ'='HSIQ'
'HFPGA'='HFPG'
'IDS-C'='IDS01'
'IDS-SR'='IDS02'
'IGA-AD'='IGAAD'
'JDA SEVERITY INDEX'='JDA'
'KPS SCALE'='KPSS'
'MADRS'='MADR'
'MDASI'='MDA'
'MOAAS'='MOAA'
'MOS SLEEP REVISED'='MOSS02'
'MOS SLEEP SCALE'='MOSS01'
'NAPSI'='NAPS'
'P-FIBS'='PFIB'
'PAIN NRS OA'='PNRS'
'PGA OA'='PGAO'
'PGAD PATIENT'='PGAD91'
'PGAD PHYSICIAN'='PGAD90'
'PHQ-9'='PHQ'
'PSS'='PSS01'
'PWC'='PWC'
'QIDS-C'='QIDS01'
'QIDS-SR'='QIDS02'
'QLQ-C30'='QLQ01'
'QLQ-MY20'='QLQ02'
'QLQ-PR25'='QLQ03'
'RLCST'='RLCS'
'SF36 V2 STANDARD'='SF363'
'SF36 v2 ACUTE'='SF364'
'SHAPS'='SHAPS'
'WHODAS 12-ITEM INTERVIEWER'='WDS01'
'WHODAS 12-ITEM SELF'='WDS02'
'WOMAC NRS'='WOMN'
'WPAI-SHP'='WPAI'
'WURSS ADD'='WURS9'
'WURSS-21'='WURS0'
;
RUN;

proc sql noprint;
  create table valdef_testcd_2 as
   select a.*, b.VALVAL as VALCAT, b.VALUEOID as VALUEOID_cat
   from valdef_testcd_1 as a 
   left join  valdef_CAT as b
   on  find(strip(a.VALVAL), strip(put(b.VALVAL , $QSCAT.)))=1 
 ;
quit;

data valdef_testcd_3;
  set valdef_testcd_2;
  if find(VALUEOID_cat,'.') ne 3 then VALUEOID= catx('.',VALUEOID_cat, VALCAT, VALUEOID ) ;
  else VALUEOID= catx('.',VALUEOID_cat, VALCAT, scan(VALUEOID,2,'.')) ;
  drop VALCAT VALUEOID_cat;
run;

data valdef;
length page VALUEOID $200;
  set valdef_testcd_3 valdef_supp  valdef_CAT1 ;
  keep VALUEOID VALVAL page freetext_ORDINAL ;
run;

proc sort data= valdef nodupkey;
  by VALUEOID VALVAL page ;
run;

/*vardef main*/
data vardef1;
  set table1;
  annotation1= tranwrd(annotation,'[','^');
  annotation1= tranwrd(annotation1,']','^');
  annotation1= tranwrd(annotation1,' when ','^');
/*  maybe we should remove where*/
/*  annotation1= tranwrd(annotation1,' where ','^');*/
  annotation1= tranwrd(annotation1,' and ','^');
  annotation1= tranwrd(annotation1,' in ','^');
  annotation1= tranwrd(annotation1,'=NOT DONE','');
  annotation1= tranwrd(annotation1,', ',',');
  annotation1= tranwrd(annotation1,' ,',',');
  
run;

title "Variable name check finding" ;
data vardef2 ;
  set vardef1;
  file print;
  array element $30 var1-var30;
  do i = 1 to 30 ;
  element[i]=scan(annotation1,i,',^');
  if find(element[i],'SUPP')=1 then VAR= element[i] ;
  if find(element[i],'=')>0 then element[i]= scan( element[i], 1,'=') ;
    if upcase(element[i]) ne element[i] then call missing(element[i]);
/*  20160607  lianbo add for COVAL in CO when IDVAR=TRGRPID issue*/
    if length(element[i])<3 then call missing(element[i]) ;
/**/
    if length(element[i])>8 then put "w!arn_ing variable "   annotation " length more than 8 char" ;
  end;

run;
title;

 data vardef3;
  set vardef2;
  array element $30 var1-var30;
  if VAR ne '' then output;
  else if VAR = '' and cmiss(of var1-var30) ne 30 then do ;
   do i = 1 to 30 ;
   call missing(VAR);
     if element[i] ne '' then do ;
       VAR= element[i] ;
       output;
     end;
   end;
  end;
keep freetext_: var ;
  run;

proc sort data= vardef3 nodupkey;
  by VAR  freetext_page;
run;

data vardef_main1 ;
length var1 var3 $8 ;
  set vardef3;
   if VAR not in( 'IDVAR') and find(VAR,'SUPP')=0;
  if VAR in('SUBJID','RFICDTC','DTHDTC','BRTHDTC','AGE','AGEU','SEX','RACE','ETHNIC','ARM','DMDTC')
  then VAR1='DM';
  else VAR1=substr(var,1,2) ;
  VAR3=VAR;

  keep VAR1 VAR3 freetext_: ;
run;

proc sort data= vardef_main1 nodupkey;
  by var1 var3 freetext_page ;
run;

data vardef_main;
length page $100 ;
retain page;
  set vardef_main1;
  by var1 var3 freetext_page ;
  if first.var3 then call missing(page);
  page= catx(', ' , page, freetext_page);
  if last.var3 then output;
  drop freetext_page ;
run;


/*vardef supp*/
data vardef_supp1;
length F1 $8 ;
  set Valdef_supp1;
  F1= scan(VALUEOID,1) ;
  _page= freetext_page;
/*  drop page;*/
run;

proc sort data= vardef_supp1 nodupkey;
  by F1 _page ;
run;

data vardef_supp2;
length page $100 ;
retain page;
  set vardef_supp1;
  by F1 _page ;
  if first.F1 then call missing(page);
  page= catx(', ' , page, _page);
  if last.F1 then output;
  drop _page VALUEOID  VALVAL;
run;

data vardef_supp;
length F3 $8;
	set vardef_supp2;
	F3= 'QLABEL' ; output;
	F3= 'QVAL';output;
run;

/*read spec*/

libname SDTMSPEC "&root.&specname" header=no SCAN_TEXT=NO ;

data Define_DATADEF;
  set SDTMSPEC.'Define_DATADEF$B6:D'n ;
  where F2 ne '';
run;
options mprint;
proc sql noprint;
  select distinct var1 into :maindomains separated by " " from Vardef_main ;
  select count( distinct var1) into :mainnum separated by " " from Vardef_main  ;
  select  distinct F1  into :suppdomains separated by " " from  Vardef_supp2; 
  select  count( distinct F1) into :suppnum separated by " " from Vardef_supp2; 
quit;

%let maindomains= &maindomains ;
%let suppdomains= &suppdomains ;
%put &maindomains;
%put &suppdomains;


/*do the valdef sheet*/
proc sql noprint;
  create table temp  as
  select page ,  F1,F2, F9     
  from SDTMSPEC.'VALDEF$A2:O'n as a
  left join  valdef as b on a.F1= b.VALUEOID AND a.F2= b.VALVAL 
;
quit;

title "VALDEF page check finding" ;
DATA SDTMSPEC.'VALDEF$A2:O'n;
 MODIFY SDTMSPEC.'VALDEF$A2:O'n  temp;
 file print;
 by F1 F9;
 if page ne '' then do ;
  if page ne F14 and find(F8,'CRF')>0 then  do ;
   put F1 '  ' F2 "aCRF page=  " F14 ' is changed to ' page ;
   F14=page;
  end;
 end;
 else do ;
   if find(F8,'CRF')>0 then do ;
   put  F1 '  ' F2 "aCRF page need check manually" ; 
   end;
 end;
RUN;
title;

/*do the vardef main domain*/
%macro loop_vardef_main ;

 %do i= 1 %to &mainnum ;

title "VARDEF Domain: %scan(&maindomains,&i)" ;

data temp_%scan(&maindomains,&i) ;
  set SDTMSPEC."%scan(&maindomains,&i)$%trim(&mainrange)"n (dbSasType=(F1=char8 F2=numeric F3=char8 ));
  where  F3 is not missing;
run;

 proc sql noprint;
  create table temp2_%scan(&maindomains,&i)  as
  select page, F1 ,F2 , F3  
  from temp_%scan(&maindomains,&i) as a
  left join  vardef_main as b on a.F1= b.VAR1 AND a.F3= b.VAR3 
;
quit;

proc sort data=temp2_%scan(&maindomains,&i) (where= (F3 ne ''));
	by F1 F2;
run;

DATA SDTMSPEC."%scan(&maindomains,&i)$%trim(&mainrange)"n (where= (F3 is not missing) );
 MODIFY SDTMSPEC."%scan(&maindomains,&i)$%trim(&mainrange)"n (where= (F3 is not missing)
     dbSasType=( F18=char100 F2=numeric F1=char8 F6=numeric  F3=char8 )  )  
     temp2_%scan(&maindomains,&i);
   file print;
 by F1 F2;
 if page ne '' then do ;
  if page ne F18 and find(F9,'CRF')>0 then do ;
     put 'VARDEF  ' F1 '  ' F3 "aCRF page=  " F18 ' is changed to ' page ;
     F18=page;
  end;
 end;
 else do ;
   if find(F9,'CRF')>0 and F3 ne 'VISIT' then do ;
    put 'VARDEF  ' F1 '  ' F3 "aCRF page need check manually" ;
   end; 
 end;

RUN;

proc datasets library=work NOlist;
delete temp2_%scan(&maindomains,&i) temp_%scan(&maindomains,&i) ;
quit;

%end;
title;
%mend;
%loop_vardef_main


/*do the vardef main domain*/
%macro loop_vardef_supp ;

 %do i= 1 %to &suppnum ;

title "VARDEF SUPPDOMAIN: %scan(&suppdomains,&i)" ;

DATA SDTMSPEC."%scan(&suppdomains,&i)$%trim(&supprange)"n (where =( F3 in ('QVAL','QLABEL')) );
 MODIFY SDTMSPEC."%scan(&suppdomains,&i)$%trim(&supprange)"n (where =( F3 in ('QVAL','QLABEL'))
     dbSasType=( F18=char100  F3=char8 )  )  
     vardef_supp (drop =freetext_ORDINAL where =(F1 ="%scan(&suppdomains,&i)")) ;
 file print;
 by F3;
 if page ne '' then do ;
  if page ne F18 and find(F9,'CRF')>0  then do ;
     put 'VARDEF  ' F1 '  ' F3 "aCRF page=  " F18 ' is changed to ' page ;
     F18=page;
  end;
 end;
 else do ;
   if find(F9,'CRF')>0 then do ;
   put 'VARDEF  ' F1 '  ' F3 "aCRF page need check manually" ; 
   end;
 end;
RUN;
%end;
title;
%mend;

%loop_vardef_supp

libname SDTMSPEC clear;
libname annotate clear;
